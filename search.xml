<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTPS中的TLS]]></title>
    <url>%2F2019%2F05%2F20%2FHTTPS%E4%B8%AD%E7%9A%84TLS%2F</url>
    <content type="text"><![CDATA[HTTPS中的TLSSSL与TLSSSL：(Secure Socket Layer)安全套接层。 TLS：(Transport Layer Security)传输层安全协议，是IETF在SSL3.0的基础上设计的协议。 从网络协议的角度理解HTTPS HTTP：HyperText Transfer Protocol 超文本传输协议HTTPS：Hypertext Transfer Protocol Secure 超文本传输安全协议TLS：位于 HTTP 和 TCP 之间的协议，其内部有 TLS握手协议、TLS记录协议HTTPS 经由 HTTP 进行通信，但利用 TLS 来保证安全，即 HTTPS = HTTP + TLS 从密码学角度理解HTTPSHTTPS使用TLS保证安全，这里安全分为两部分，一是传输内容加密，二是服务端的身份认证。 TLS工作流程 上图为服务端单向认证，还有C/S双向认证，流程类似，但是客户端也有自己的证书，并且发送给服务器进行认证。 密码基础 伪随机数生成器 没有真正意义上的随机数，作用主要用于生产对称密码的密钥，用于公钥密码生成密钥对。 消息认证码 消息认证码：用于验证消息完整性和消息认证。（防止篡改和伪装） 发送者与接收者事先共享秘钥 发送者根据发送消息计算 MAC 值 发送者发送消息和 MAC 值 接收者根据接收到的消息计算 MAC 值 接收者根据自己计算的 MAC 值与收到的 MAC 对比 如果对比成功，说明消息完整，并来自与正确的发送者 数字签名 消息认证码缺点是无法防止否认，因为共享密钥被client, server两端拥有，server可以伪造client发送给自己的消息，这时候就需要各自的密钥不被第二个知晓。 数字签名和消息认证码都不是为了加密， 可以将单向散列函数获取的散列值的过程理解为使用md5摘要算法获取摘要的过程 使用自己的私钥对自己所认可的消息生成一个该消息专属的签名，这就是数字签名，表明我承认该消息来自自己注意：私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人 公钥密码公钥密码也叫非对称密码，由公钥和私钥组成，它是最开始是为了解决秘钥的配送传输安全问题，即，我们不配送私钥，只配送公钥，私钥由本人保管它与数字签名相反，公钥密码的私钥用于解密、公钥用于加密，每个人都可以用别人的公钥加密，但只有对应的私钥才能解开密文 client：明文 + 公钥 = 密文server：密文 + 私钥 = 明文注意：公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容 证书证书：全称公钥证书（Public-Key Certificate, PKC）,里面保存着归属者的基本信息，以及证书过期时间、归属者的公钥，并由认证机构（Certification Authority, CA）施加数字签名，表明，某个认证机构认定该公钥的确属于此人 密码小结 密码 作用 组成 消息认证码 确认消息的完整、并对消息的来源认证 共享秘钥+消息的散列值 数字签名 对消息的散列值签名 公钥+私钥+消息的散列值 公钥密码 解决秘钥的配送问题 公钥+私钥+消息 证书 解决公钥的归属问题 公钥密码中的公钥+数字签名 TLS使用的密码技术 伪随机数生成器：秘钥生成随机性，更难被猜测 对称密码：对称密码使用的秘钥就是由伪随机数生成，相较于非对称密码，效率更高 消息认证码：保证消息信息的完整性、以及验证消息信息的来源 公钥密码：证书技术使用的就是公钥密码 数字签名：验证证书的签名，确定由真实的某个 CA 颁发 证书：解决公钥的真实归属问题，降低中间人攻击概率 参考 SSL加密发生在哪里：https://security.stackexchange.com/questions/19681/where-does-ssl-encryption-take-place TLS工作流程：https://blog.csdn.net/ustccw/article/details/76691248 《图解密码技术》：https://book.douban.com/subject/26822106/ 豆瓣评分 9.5]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>web</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis的使用场景]]></title>
    <url>%2F2019%2F05%2F19%2FRedis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Redis使用场景1缓存作为key-value形态的内存数据库，使用Redis缓存数据非常简单，只需要通过String类型将序列化后的对象存起来即可。 序列化(Serialization):是将对象的状态信息转化为可以存储或传输的形式的过程。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。 不过也有需要注意的地方： 必须保证不同对象的key不可以重复，并且key尽量短，一半使用类名加主键拼接而成。 选择一个有序的序列化方式也很重要，目的是提高序列化效率和减少内存占用。 缓存期间的数据一致性。一半有两种做法： 只在数据库查询后将对象放入缓存，如果对象发生了删除或者修改操作，直接清除对应缓存（或者设置为过期） 在数据库新增和查询后将对象放入缓存，修改后更新缓存，删除后清除对应缓存，或者设置为过期。 2消息队列Redis中的list的数据结构实现的是双向链表，所以可以非常便捷的应用于消息队列（生产者/消费者模型）。消息的生产者只需要通过lpush将消息放入list，消费者可以通过rpop取出该消息，并且保证消息的有序性。 如果需要实现带有优先级的消息队列也可以选择sorted list。而pub/sub也可以作为发布者/订阅者模型的消息。由于Redis带有持久化功能，无需担心由于服务器故障导致消息丢失的情况发生。 有序集合的对象编码可以是ziplist或者skiplist 3时间轴list作为双向链表，不光可以作为队列使用，如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过lpush将它存放在一个key为LATEST_WEIBO的list中。之后便可以通过lrange取出最新的微博。 4排行榜使用sortedset可以轻松打造一个热度排行榜，zrevrangebyscore可以得到以分数倒序排列的序列，zrank可以得到成员在该排行榜中的作用。 5计数器计数功能应该是最适合redis的使用场景之一，高频率读写特性完全可以发挥redis作为内存数据库的高效。在Redis的数据结构中,string, hash, 和sorted set都提供了incr方法用于原子性自增操作，下面举例说明它们各自的应用场景： 如果应用需要显示每天注册用户数，便可以使用String作为计数器，设定一个名为REGISTERED_COUNT_TODAY的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用incr命令使该 key 增长 1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。 每条微博都有点赞数，评论数，转发数和浏览数四条属性，这是用hash进行计数会更好，该计数器的key设为为weibo:weibo_id，hash的 field 为like_number、comment_number、forward_number和view_number，在对应操作后通过hincrby使hash 中的 field 自增。 如果应用有一个发帖排行榜的功能，便选择sorted set吧，将集合的 key 设为POST_RANK。当用户发帖后，使用zincrby将该用户 id 的 score 增长 1。sorted set会重新进行排序，用户所 在排行榜的位置也就会得到实时的更新。 6好友关系一篇介绍微博Redis应用的PPT中，其中提到微博的Redis主要用在计数和好友关系两方面， 《Redis设计与实现》中作者最开始使用Redis中的set是因为传统数据库无法计算集合的交集。 对于一个用户A，将它的关注和粉丝的用户id都存放到两个set中： A:follow:存放A所有关注的用户id A:follower:存放A所有粉丝的用户id 那么通过sinter命令便可以根据A:follow和A:follower的交集得到与 A 互相关注的用户。当 A 进入另一个用户 B 的主页后，A:follow和B:follow的交集便是 A 和 B 的共同专注，A:follow和B:follower的交集便是 A 关注的人也关注了 B。 7分布式锁在Redis2.6.12版本开始，string的set命令增加了三个参数： Ex：设置键的过期时间（s） Px: 设置键的过期时间（ms) NX|XX：当设置为NX时，仅当key存在才进行操作，设置为xx时，仅当key不存在才会进行操作，这个操作是原子性的，可以简单实现一个分布式锁，例如： 1set key "lock" Ex 1 xx 如果操作返回false,说明key的添加不成功，即当前有人占用这把锁，而如果返回true,说明得到了锁，可以继续进行操作，操作后通过del释放掉锁，并且即使程序因为某些原因没有释放锁，设置了过期时间，所以该锁也会在1秒后自动释放。 8倒排索引倒排索引是构造搜索功能的最常见的方式，Redis中也可以通过set建立倒排索引，这里以简单的拼音+前缀搜索城市功能举例: 假设一个城市北京，通过拼音词库将北京转为beijing，再通过前缀分词将这两个词分为若干个前缀索引，有：北、北京、b、be…beijin和beijing。将这些索引分别作为set的 key（例如:index:北）并存储北京的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的set并得到其中的 id 即可。 参考文献Redis应用场景 Redis在新浪微博中的应用]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库基础</tag>
        <tag>应用场景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis之RDB持久化]]></title>
    <url>%2F2019%2F05%2F19%2FRedis%E4%B9%8BRDB%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Redis之RDB持久化1RDB持久化的概念​ 因为Redis数据库是一个内存数据库，一旦服务器进程退出，那么服务器中的数据库状态也会消失不见，为了解决这个问题，redis提供了RDB（Redis DataBase file）持久化功能。可以将redis中的数据库状态保存到磁盘中，避免数据的意外丢失。 2RDB文件的创建和载入​ 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。 SAVE会阻塞Redis服务进程，直到RDB文件完全创建完毕，在阻塞进程时服务器不能处理任何请求命令。 BGSAVE则不同，它会派生出一个子进程，由子进程负责创建RDB文件，服务器进程则继续处理请求。 3自动间隔性保存​ 因为BGSAVE命令可以在不阻塞服务器进程的情况执行。用户可以通过设置save选项设置多个保存条件，比如 123save 900 1 /*900s内有一次保存*/save 300 10 /*300sb内有10次保存*/save 60 10000 /*60s内有10000次保存*/ 只要满足上述条件之一就会触发BGSAVE命令。检查保存条件是否满足的serverCron函数默认每隔100ms就会检测一次。 4重点回顾 RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。 SAVE命令由服务器进程直接执行保存操作，该命令会阻塞服务器进程。 BGSAVE命令由子进程执行保存操作，不会阻塞服务器进程。 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。 RDB文件是一个经过压缩的二进制文件，由多个部分组成。 对于不同类型的键值对，RDB文件以不同的形式保存。 5RDB的缺陷​ 通过上述对RDB持久化的描述可以看出，RDB有他的不足之处，就是一旦数据库出现问题，由于RDB文件不是最新的，那么从RDB文件上一次自动保存到出现故障的这段时间内的数据就丢失了，所以RDB持久化不适用于对数据安全性要求极高的应用。]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库基础</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构之简单动态字符串]]></title>
    <url>%2F2019%2F05%2F19%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Redis的数据结构-简单动态字符串SDS1.SDS的定义sds结构: 123456789struct sdshdr&#123; //记录buf数组中已经使用的字节数量 //等于SDS中所保存字符串的长度 int len; //记录buf数组中未使用字节的数量 int free; //字节数组 char[] buf&#125; SDS遵循C字符串以空字符结尾的习惯，保存空字符的一字节空间不记录到len属性中。这样的好处是可以使用部分c语言的库函数。 2.SDS与c语言字符串的区别2.1常数复杂度获取字符串长度c语言不记录自身字符串长度，需要遍历一遍得到字符串的大小。而SDS维护了len变量，直接O(1)复杂度获取。 2.2杜绝缓冲区溢出c不记录自身长度容易造成缓冲区溢出。而sds会首先检查sds的空间是否满足修改要求，不满足的话会自动实现扩容。 2.3减少修改字符串时带来的内存重新分配次数Redis作为内存数据库，经常被用于速度要求高，数据被频繁修改的场合。sds通过未使用空间解除了字符串长度和底层数组长度之间的关联。 空间预分配 当sds对sds进行修改并且sds需要扩展时，程序不仅会为sds分配修改所必须要的空间，而且还会为sds分配额外的未使用空间。 策略为，若sds长度小于1MB，则分配与len相同大小的未使用空间。即len与free属性相同。若对sds进行修改，长度大于1MB,程序会分配1MB未使用空间。 在扩容之前，会检测未使用空间是否足够，足够的话直接使用未使用空间而无需进行扩容。 惰性空间释放 当sds的api需要缩短时，并不立即内存重新分配，而是使用free属性来将这些字节数量记录并等待使用。 2.4二进制安全为了确保Redis可以使用于不同场景，SDS的API都是二进制安全的，所有的SDS API都会以处理二进制的方式来处理SDS存放在buf数组中的数据，不会对其中的数据做任何限制，过滤和假设。 2.5兼容部分c字符串函数sds遵循c字符串以空字符结尾的习惯，从而可以利用部分c的库函数]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库基础</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构之跳跃表]]></title>
    <url>%2F2019%2F05%2F19%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Redis数据结构之跳跃表1.跳跃表的定义跳跃表是一种有序数据结构，通过每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 支持平均O(logN)，最坏时间复杂度为O(N)复杂度的节点查找，还可以通过顺序性操作批量处理节点。 跳跃表在Redis里的用处：一是实现有序集合，另一个是在集群节点中用作内部数据结构。 2.跳跃表的实现Redis的跳跃表由zskiplistNode和zskiplist两个结构定义。跳跃表结构如下 左边的是zskiplist结构，该结构包含以下属性： header:指向跳跃表的表头节点。 tail：指向跳跃表的表尾节点。 level：记录目前跳跃表中节点最大的层数。（不包含表头节点） length：记录跳跃表的长度，跳跃表目前的节点数量。（不包含表头节点） 其余四个结构是zskiplistNode结构，包含以下属性： level：节点用L1，L2等字样标记节点的各个层，L1代表第一层，L2第二层以此类推，每层包含两个属性：前进指针和跨度，前进指针用于访问表尾方向的其他节点，而跨度是前进指针指向节点和当前节点的距离。 backward(后退指针)：节点中用BW字样标记节点的后退指针，指向位于当前节点的前一个节点。 score：跳跃表节点按分值由大到小排列。 obj：成员对象，指向节点保存的成员对象。 2.1跳跃表节点redis.h/zskiplistNode 123456789101112131415typedef struct zskiplistNode&#123; //层 struct zskiplistLevel&#123; //前进指针 struct zskiplistNode *forward; //跨度 unsigned int span; &#125;level[], //后退指针 struct zskiplistNode *backward; //分支 double score; //成员对象, robj *obj;&#125;zskiplistNode; 层每次创建一个新的跳跃表节点时，程序都会根据幂次定律生成一个0~32之间的数 幂次定律：越大的数生成的概率越小。 前进指针用于访问表头到表尾的节点 跨度其用途是用于计算节点在链表中的位置。 后退指针每次只能后退一个节点。 分值和成员分值用于节点间的排序。 成员对象指向一个字符串，字符串对象存放着一个SDS值。这个值代表着具体的对象类型。 2.2跳跃表实现redis.h/zskiplist 12345678typedef struct zskiplist&#123; //表头节点和表尾节点 struct zskiplistNode *header, *tail; //节点数量 int length; //表中层数最大的节点的层数 int level;&#125;zskiplist; 3总结跳跃表是有序集合的底层实现之一(另一个是压缩列表)。 跳跃表由zskiplist和zskiplistNode两个节点实现。 每个跳跃表节点的层高是1~32之间的随机数。 多个节点可以包含相同的分值，但每个节点的成员对象是唯一的。 跳跃表中节点按分值大小排序，分值相同的按对象大小排序。]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库基础</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构之字典]]></title>
    <url>%2F2019%2F05%2F19%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[Redis数据结构之字典字典是一种保存键值对的抽象数据结构。在字典中，一个键可以和一个值进行关联，这些关联的键和值就称为键值对。 Redis的数据库就是通过字典作为其底层实现的。对数据库的增删改查都是建立在字典的操作之上。 1.字典的实现Redis的字典使用hash表作为底层实现 1.1哈希表Redis字典所使用的哈希表结构定义如下 1234567891011121314typedef struct dictht&#123; //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于size-1 unsigned long sizemask; //该哈希表已有节点的数量 unsigned long used;&#125;dictht; dictEntry结构保存着一个键值对。size属性记录了哈希表大小，也即是table数组的大小。 used属性指的是当前哈希表目前已有节点的数量。 1.2哈希表节点哈希表节点用dictEntry结构表示，每个dictEntry结构都保存着一个键值对。 1234567891011121314typedef struct dictEntry&#123; //键 void *key; //值 union&#123; void *val; uint64_tu64; int64_ts64; &#125;v; //指向下个哈希表节点，形成链表 struct dictEntry *next;&#125;dicEntry; 其中键值对的值可以是一个指针，或者是uint64_t整数，又或者是一个int64_t整数。 next属性是指向另一个哈希表节点的指针，将多个哈希值相同的键值对连接在一起，以此来解决键冲突问题。 1.3字典Redis中字典由dict.h/dict结构表示: 123456789101112131415typedef struct dict&#123; //类型特定函数 dictType *type; //私有数据 void *privdata; //哈希表 dictht ht[2]; //rehash索引 //当rehash不在进行时，值为-1 int trehashidx;/*rehashing not in processing if rehashidx = -1;*/ &#125;dict; 其中type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的： type属性是一个指向dictType结构的指针，每个 dictType结构表存了一簇操作特定类型键值对的函数，redis 会为用途不同的字典设置不同类型的特定函数。 123456789101112typedef struct dictType&#123; //计算哈希值的函数 unsigned int (*hashFunction)(const void *key); //复制键的函数 void *(*keyDup)(void *privdata, const void *key;) //复制值的函数 void *(*valDup)(void *privdata, const void *obj;) .... &#125; ht属性是一个包含了两个项的数组，数组中每一项都是dictht哈希表。一般情况下只使用ht[0],在rehash的时候才会使用ht[1]. 2哈希算法Redis计算哈希值和索引值的方法如下： 12#使用字典设置的哈希函数，计算键key的哈希值hash = dict-&gt;type-&gt;hashfunction（key）； 123#使用hash表的sizemask属性和哈希值计算出索引值#根据使用情况的不同，ht[x]可以是ht[0]或者ht[1]index = hash &amp; dict -&gt; ht[x].sizemask; 例如，我们要将一个键值对k0和v0添加到字典里面： 计算键k0的hash值，hash = dict-&gt;type-&gt;hashFunction(k0); 假设计算所得的hash值为8，那么程序会继续使用语句：index = hash&amp;dict-&gt;ht[0].sizemask = 8&amp;3 = 0; 计算出键k0的索引值为0，这表示包含键值对k0和v0的节点被放置到哈希表数组的索引0位置上 。 MurmurHash算法：Redis使用Murmurhash2 3解决键冲突键冲突的定义:当两个或者以上的键被分配到了hash表数组的同一个索引上，我们称这些键发生了冲突。 Redis的哈希表使用链地址法解决键冲突。其中由于dictEntry没有指向表尾的指针，新节点采取头插法。 4rehash为了让哈希表的负载因子在一个合理范围内，程序需要对哈希表进行扩展和收缩。 rehash的操作： 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量。 扩展操作，ht[1]的大小等于第一个ht[0].used*2的2^n 收缩操作，ht[1]的大小等于 第一个ht[0].used的2^n 2.将保存在ht[0]上的所有键值对rehash到ht[1]上,rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。 3.将ht[0]包含的所有键值对都迁移到ht[1]上，释放ht[0]，将ht[1]变成ht[0],并且创建一个新的ht[1]. 哈希表的负载因子计算： load_factor = ht[0].used / ht[0].size 5渐进式rehash扩展或者收缩得到哈希表需要将ht[0]里面的所有键值对rehash到ht[1]中，但是rehash的过程并不是一次性完成的，rehash的动作是分多次，渐进式地完成的。 详细步骤如下： 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个hash表。 在字典中维持一个索引计数器变量rehashidx,将其值设为0，表示rehash工作开始。 rehash进行期间，每次对字典进行增删改查时，除了执行指定操作，还顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]上。 随着字典操作的不断执行，最终在某个时间点ht[0]完全被rehash到ht[1]. 在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的增删改查需要在两个表上进行，例如，在ht[0]中未找到，继续到ht[1]里面进行查找。 参考文献《Redis设计与实现》–黄健宏，机械工业出版社]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库基础</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的缺点和采取措施]]></title>
    <url>%2F2019%2F05%2F19%2FHTTP%E7%9A%84%E7%BC%BA%E7%82%B9%E5%92%8C%E9%87%87%E5%8F%96%E6%8E%AA%E6%96%BD%2F</url>
    <content type="text"><![CDATA[HTTP的缺点和采取的措施1http的主要不足 通信使用明文，内容可能会被窃听。 不验证通信方身份，可能遭遇伪装。 无法证明报文完整性,可能遭到篡改。 2http加密处理措施 通信的加密：通过SSL(secure socket layer)或者TLS(Transport Layer Security安全传输协议)的组合使用。 内容的加密：通过对通信传输内容本身加密，报文主题的内容被加密处理，这需要客户端和服务端同时具有加密和解密的能力。 3http验证通信方身份措施 HTTP协议不存在验证通信方的处理步骤，任何人都可以发送请求，无法确定请求是否到达真正的服务器，无法确定响应是否返回到真的客户端，无法确定对方是否有访问权限，无法判断请求来源，无法阻止海量DOS攻击。 使用SSL可以查明对方的证书，SSL不仅提供加密服务，而且提供证书来确定对方，证书由值得信赖的第三方机构颁发，对于服务端和客户端，持有证书即可完成身份的确认。 4http验证报文完整性的措施 接收到的内容可能有误，因为http协议无法证明通信完整性，像这样在传输途中遭遇拦截并且篡改内容的攻击称为中间人攻击。常常使用SHA-1和MD5等散列值校验的方法以及确认文件的数字签名的方法。]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，Hexo]]></title>
    <url>%2F2019%2F05%2F19%2F%E4%BD%A0%E5%A5%BD%EF%BC%8CHexo%2F</url>
    <content type="text"><![CDATA[使用Hexo，是非常简单的事情！]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>git</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
